from PyQt5.QtWidgets import QApplication, QMainWindow, QSplitter, QFileDialog, QLabel, QVBoxLayout, QWidget, \    QHBoxLayout, QFileSystemModel, QTextEdit, QPlainTextEdit, QTabWidget, QLineEdit, QPushButton, QDialogfrom PyQt5.QtCore import Qt, QSortFilterProxyModelfrom PyQt5.QtGui import QPixmap, QTextDocument, QIconfrom PyQt5 import uicfrom utils import load_file, run, save, newfrom syntax_highlighter import SyntaxHighlighterfrom pathlib import Pathimport webbrowserimport osimport threadingfrom http.server import SimpleHTTPRequestHandler, HTTPServerSUPPORTED_FILE_TYPES = "*.*;; *.py;; *.cpp;; *.html;; *.css;; *.js;; *.json;; *.txt;; *.png;; *.jpg;; *.jpeg"class RefactorDialog(QDialog):    def __init__(self, parent=None):        super().__init__(parent)        self.setWindowTitle("Refactor")        self.setWindowIcon(QIcon("C:/Users/Jason Chundusu/Desktop/Code 8/Assets/Icons/eight (1)"))        self.setFixedSize(320, 150)        # Input field        self.line_edit = QLineEdit()        self.line_edit.setMaximumHeight(35)        self.refactor_btn = QPushButton("Refactor")        self.refactor_btn.setMaximumWidth(120)        self.cancel_btn = QPushButton("Cancel")        # Layout        btn_layout = QHBoxLayout()        btn_layout.addWidget(self.refactor_btn)        btn_layout.addWidget(self.cancel_btn)        layout = QVBoxLayout()        layout.addWidget(self.line_edit)        layout.addLayout(btn_layout)        self.setLayout(layout)        # Signals        self.refactor_btn.clicked.connect(self.accept)        self.cancel_btn.clicked.connect(self.reject)    def get_text(self):        return self.line_edit.text()class NewFileDialog(QDialog):    def __init__(self, parent=None):        super().__init__(parent)        self.setWindowTitle('Cre8 File')        self.setWindowIcon(QIcon("C:/Users/Jason Chundusu/Desktop/Code 8/Assets/Icons/eight (1)"))        self.setFixedSize(320, 150)        self.line_edit = QLineEdit()        self.line_edit.setPlaceholderText("Enter filename")        self.line_edit.setMaximumHeight(35)        self.create_btn = QPushButton("Cre8!")        self.create_btn.setMaximumWidth(120)        self.create_btn.setEnabled(False)        self.line_edit.textChanged.connect(self.validate_input)        self.cancel_btn = QPushButton("Cancel")        btn_layout = QHBoxLayout()        btn_layout.addWidget(self.create_btn)        btn_layout.addWidget(self.cancel_btn)        layout = QVBoxLayout()        layout.addWidget(self.line_edit)        layout.addLayout(btn_layout)        self.setLayout(layout)        # Signals        self.create_btn.clicked.connect(self.accept)        self.cancel_btn.clicked.connect(self.reject)    def get_path(self) -> str:        return self.line_edit.text()    def validate_input(self, text):        self.create_btn.setEnabled(bool(text.strip()))class MainWindow(QMainWindow):    def __init__(self):        super().__init__()        uic.loadUi("C:\\Users\\Jason Chundusu\\Desktop\\Code 8\\Assets\\UI Files\\c8.1.3.ui", self)        self.setWindowTitle("Code 8")        self.setWindowIcon(QIcon("C:/Users/Jason Chundusu/Desktop/Code 8/Assets/Icons/eight (1)"))        self.server_thread = None        self.httpd = None        self.current_folder_path = ''        self.model = QFileSystemModel()        self.model.setRootPath("")        self.proxyModel = QSortFilterProxyModel()        self.proxyModel.setSourceModel(self.model)        self.proxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)        self.proxyModel.setFilterKeyColumn(0)  # Filter only file/folder names        self.tabs = {}  # Maps tab index to editor-related data        self.tab_widget = QTabWidget()        self.tab_widget.setTabsClosable(True)        self.tab_widget.setMovable(True)        self.tab_widget.currentChanged.connect(self.switch_tab)        tabs = self.tab_widget        tabs.tabCloseRequested.connect(self.close_)        # Output area setup        self.terminal = QWidget()        self.terminal_output.setReadOnly(True)        terminal_layout = QVBoxLayout()        terminal_layout.setContentsMargins(0, 0, 0, 0)        terminal_layout.addWidget(self.terminal_output)        terminal_layout.addWidget(self.terminal_input)        self.terminal.setLayout(terminal_layout)        self.splitter1 = QSplitter(Qt.Vertical)        self.splitter1.addWidget(self.tab_widget)        self.splitter1.addWidget(self.terminal)        self.splitter1.setStretchFactor(0, 3)        self.splitter1.setStretchFactor(1, 2)        self.original_split_sizes = self.splitter1.sizes()        layout = QVBoxLayout()        self.run_btn.setMaximumWidth(80)        layout.addWidget(self.run_btn)        layout.addWidget(self.splitter1)        container = QWidget()        container.setLayout(layout)        # Tree views        tree_search = QLineEdit()        self.tree_close_btn = QPushButton()        self.tree_close_btn.setText("X")        self.tree_btn_widget = QWidget()        tree_btn_layout = QHBoxLayout()        tree_btn_layout.setContentsMargins(0, 0, 0, 0)        tree_btn_layout.addWidget(tree_search)        tree_btn_layout.addWidget(self.tree_close_btn)        self.tree_btn_widget.setLayout(tree_btn_layout)        tree_layout = QVBoxLayout()        self.tree_main_widget = QWidget()        tree_layout.setContentsMargins(0, 0, 0, 0)        tree_layout.addWidget(self.tree_btn_widget)        tree_layout.addWidget(self.tree_view)        self.tree_main_widget.setLayout(tree_layout)        self.splitter = QSplitter(Qt.Horizontal)        self.splitter.addWidget(self.tree_main_widget)        self.splitter.addWidget(container)        self.splitter.setStretchFactor(0, 1)        self.splitter.setStretchFactor(1, 4)        self.original_split_sizes_ = self.splitter.sizes()        main = QWidget()        main_layout = QHBoxLayout()        self.side_tool_widget.setMaximumWidth(33)        main_layout.addWidget(self.side_tool_widget)        main_layout.addWidget(self.splitter)        main.setLayout(main_layout)        self.setCentralWidget(main)        # Status bar        self.autoSaveLabel = QLabel("Auto Save: Off")        self.statusLabel = QLabel("Untitled File")        self.statusBar().addPermanentWidget(self.autoSaveLabel)        self.statusBar().addPermanentWidget(self.statusLabel)        # Connect actions        self.run_btn.clicked.connect(self.run_)        self.actionSave.triggered.connect(self.save_)        self.actionSave_as.triggered.connect(self.save_as)        self.actionNew.triggered.connect(self.new_)        self.actionOpen.triggered.connect(self.open_)        self.actionClose.triggered.connect(self.close_)        self.actionAuto_save.setCheckable(True)        self.actionAuto_save.toggled.connect(self.toggle_auto_save)        self.tree_close_btn.clicked.connect(self.tree_close)        tree_search.textChanged.connect(self.tree_search)        self.actionOpen_Folder.triggered.connect(self.open_folder)        self.actionRefactor.triggered.connect(self.refactor)        self.folder_btn.clicked.connect(self.tree_toggles)        self.terminal_btn.clicked.connect(self.terminal_toggle)        self.actionFind_next_occurence.triggered.connect(self.next_occurrence)        self.actionFind_previous_occurence.triggered.connect(self.previous_occurrence)        # Add default tab        self.add_tab("Untitled", '', '', '')    def add_tab(self, name, content, path, extension):        if extension.lower() in ("jpeg", "png", "jpg"):            image_label = QLabel()            pixmap = QPixmap(path)            image_label.setPixmap(pixmap)            image_label.setScaledContents(True)            wrapper_layout = QVBoxLayout()            wrapper_layout.addWidget(image_label)            wrapper = QWidget()            wrapper.setLayout(wrapper_layout)            index = self.tab_widget.addTab(wrapper, name)            self.tabs[wrapper] = {                "editor": None,                "line_number": None,                "path": path,                "extension": extension,                "highlighter": None            }        else:            line_number = QTextEdit()            line_number.setReadOnly(True)            line_number.setFixedWidth(75)            line_number.setLineWrapMode(QTextEdit.NoWrap)            line_number.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)            code_area = QPlainTextEdit()            code_area.setPlainText(content)            code_area.setLineWrapMode(QPlainTextEdit.NoWrap)            code_area.updateRequest.connect(lambda rect, dy: self.update_line_numbers(code_area, line_number, rect, dy))            highlighter = SyntaxHighlighter(code_area.document())            highlighter.set_language(extension)            wrapper_layout = QHBoxLayout()            wrapper_layout.addWidget(line_number)            wrapper_layout.addWidget(code_area)            wrapper = QWidget()            wrapper.setLayout(wrapper_layout)            index = self.tab_widget.addTab(wrapper, name)            self.tabs[wrapper] = {                "editor": code_area,                "line_number": line_number,                "path": path,                "extension": extension,                "highlighter": highlighter            }        self.tab_widget.setCurrentIndex(index)    def current_tab_data(self):        return self.tabs.get(self.tab_widget.currentWidget(), {})    def switch_tab(self, index):        data = self.tabs.get(self.tab_widget.currentWidget(), {})        file_path = data.get("path", "Untitled File")        self.statusLabel.setText(file_path)    def update_line_numbers(self, editor, line_number_widget, rect, dy):        if rect.height() == 0 and dy == 0:            return        block = editor.firstVisibleBlock()        visible = []        block_number = block.blockNumber()        top = editor.blockBoundingGeometry(block).translated(editor.contentOffset()).top()        bottom = editor.viewport().height()        while block.isValid() and top <= bottom:            visible.append(str(block_number + 1))            top += editor.blockBoundingRect(block).height()            block = block.next()            block_number += 1        line_number_widget.setPlainText('\n'.join(visible))    def toggle_auto_save(self, checked):        editor = self.current_tab_data().get("editor")        if editor:            if checked:                editor.textChanged.connect(self.auto_save)                self.autoSaveLabel.setText("Auto Save: On")            else:                editor.textChanged.disconnect(self.auto_save)                self.autoSaveLabel.setText("Auto Save: Off")    def auto_save(self):        data = self.current_tab_data()        if data.get("path"):            save(data["editor"].toPlainText(), data["path"])            self.statusBar().showMessage("Auto-saved", 2000)    def open_(self):        file_info = QFileDialog.getOpenFileName(self, "Open File", "", SUPPORTED_FILE_TYPES)        if file_info[0]:            extension = Path(file_info[0]).suffix.lstrip('.')            name = Path(file_info[0]).name            if extension in ["png", "jpg", "jpeg"]:                self.add_tab(name, '', file_info[0], extension)            else:                content = load_file(file_info[0])                self.add_tab(name, content, file_info[0], extension)                self.statusBar().showMessage("File Opened Successfully", 3000)                self.close_default_tab()    def save_(self):         data = self.current_tab_data()         if data.get("path"):             save(data["editor"].toPlainText(), data["path"])             self.statusBar().showMessage("File Saved Successfully", 3000)    def save_as(self):        data = self.current_tab_data()        file = QFileDialog.getSaveFileName(self, "Save File As", data.get("path", ""), SUPPORTED_FILE_TYPES)        if file[0]:            save(data["editor"].toPlainText(), file[0])            data["path"] = file[0]            data["extension"] = Path(file[0]).suffix.lstrip('.')            self.statusLabel.setText(file[0])            highlighter = data.get("highlighter")            highlighter.set_language(data["extension"])            highlighter.rehighlight()    def new_(self):        file = ''        file_name = ''        dialog = NewFileDialog(self)        if dialog.exec_():            file_name = dialog.get_path()        if self.current_folder_path and file_name:            file = self.current_folder_path + file_name        elif file_name:            path = QFileDialog.getExistingDirectory(self, "Select Folder")            file = f"{path}/{file_name}"            if not path:                return        if file:            new(file)            extension = Path(file).suffix.lstrip('.')            name = Path(file).name            self.add_tab(name, '', file, extension)            self.close_default_tab()    def close_(self):        index = self.tab_widget.currentIndex()        if index >= 0:            self.tab_widget.removeTab(index)            self.tabs.pop(index, None)            if self.tab_widget.count() == 0:                self.add_tab("Untitled", '', '', '')    def run_(self):        sizes = self.splitter1.sizes()        if sizes[1] == 0:            self.splitter1.setSizes(self.original_split_sizes)        data = self.current_tab_data()        if not data.get("path"):            self.statusBar().showMessage("No file to run", 2000)            return        extension = data["extension"]        file_path = data["path"]        if extension in ["html", "htm"]:            directory = os.path.dirname(file_path)            filename = os.path.basename(file_path)            port = 8000            # Stop previous server if running            if self.httpd:                self.httpd.shutdown()                self.httpd = None            def start_server():                os.chdir(directory)                self.httpd = HTTPServer(('localhost', port), SimpleHTTPRequestHandler)                self.httpd.serve_forever()            self.server_thread = threading.Thread(target=start_server, daemon=True)            self.server_thread.start()            # Open the file in browser via localhost            webbrowser.open(f"http://localhost:{port}/{filename}")            self.terminal_output.clear()            self.terminal_output.append(f"Serving {filename} at http://localhost:{port}/")        elif extension in ["css", "js"]:            self.terminal_output.clear()            self.terminal_output.append("Please run the HTML file that links to this CSS/JS.")        elif extension in ["py", "cpp"]:            result = run(file_path)            self.terminal_output.clear()            self.terminal_output.append(result)        else:            self.terminal_output.clear()            self.terminal_output.append("Cannot run this file type.")    def tree_view_loader(self, folder):        try:            self.tree_view.setModel(self.proxyModel)            root_index = self.model.index(folder)            self.tree_view.setRootIndex(self.proxyModel.mapFromSource(root_index))            self.tree_view.setHeaderHidden(True)            self.tree_view.hideColumn(1)            self.tree_view.hideColumn(2)            self.tree_view.hideColumn(3)        except Exception as e:            self.statusBar().showMessage(str(e), 3000)    def tree_search(self, text):        self.proxyModel.setFilterWildcard(f"*{text}*")    def tree_close(self):        self.splitter.setSizes([0, 1])  # Collapses first, expands second    def tree_toggles(self):        sizes = self.splitter.sizes()        if sizes[0] == 0:            self.splitter.setSizes(self.original_split_sizes_)        else:            self.original_split_sizes_ = sizes  # Save before collapsing            self.splitter.setSizes([0, sizes[1] + sizes[0]])    def terminal_toggle(self):        sizes = self.splitter1.sizes()        if sizes[1] == 0:            self.splitter1.setSizes(self.original_split_sizes)        else:            self.original_split_sizes = sizes  # Save before collapsing            self.splitter1.setSizes([sizes[0] + sizes[1], 0])    def open_folder(self):        dialog = QFileDialog()        dialog.setFileMode(QFileDialog.Directory)        folder = dialog.getExistingDirectory(self, "Select Folder")        if folder:            self.tree_view_loader(folder)            self.current_folder_path = folder            self.statusBar().showMessage("Folder Opened Successfully", 3000)    def close_default_tab(self):        for widget, data in self.tabs.items():            if data["path"] == "" and self.tab_widget.tabText(self.tab_widget.indexOf(widget)) == "Untitled":                self.tab_widget.removeTab(self.tab_widget.indexOf(widget))                del self.tabs[widget]                break    def highlighted_word(self):        editor = self.current_tab_data()["editor"]        cursor = editor.textCursor()        return cursor.selectedText(), editor    def refactor(self):        selected_text, editor = self.highlighted_word()        dialog = RefactorDialog(self)        if dialog.exec_():  # Waits for dialog to be accepted            new_text = dialog.get_text()            if new_text:                updated_doc = editor.toPlainText().replace(selected_text, new_text)                editor.setPlainText(updated_doc)                self.statusBar().showMessage(f"Replaced all '{selected_text}' with '{new_text}'", 2000)    def next_occurrence(self):        word, editor = self.highlighted_word()        editor.find(word)    def previous_occurrence(self):        word, editor = self.highlighted_word()        editor.find(word, QTextDocument.FindBackward)if __name__ == "__main__":    app = QApplication([])    window = MainWindow()    window.showMaximized()    app.exec_()